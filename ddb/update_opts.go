package ddb

import (
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

// UpdateOptions customises Update and CreateUpdateItem via chainable methods.
type UpdateOptions struct {
	// EnableOptimisticLocking is true by default to add optimistic locking.
	EnableOptimisticLocking bool
	// EnableAutoGeneratedTimestamps is true by default to add generated timestamp attributes.
	EnableAutoGeneratedTimestamps bool

	// TableName modifies the [dynamodb.UpdateItemInput.TableName]
	TableName *string
	// ReturnConsumedCapacity modifies the [dynamodb.UpdateItemInput.ReturnConsumedCapacity]
	ReturnConsumedCapacity types.ReturnConsumedCapacity
	// ReturnItemCollectionMetrics modifies the [dynamodb.UpdateItemInput.ReturnItemCollectionMetrics]
	ReturnItemCollectionMetrics types.ReturnItemCollectionMetrics
	// ReturnValues modifies the [dynamodb.UpdateItemInput.ReturnValues]
	ReturnValues types.ReturnValue
	// ReturnValuesOnConditionCheckFailure modifies the [dynamodb.UpdateItemInput.ReturnValuesOnConditionCheckFailure].
	ReturnValuesOnConditionCheckFailure types.ReturnValuesOnConditionCheckFailure

	// used by CreateUpdateItem.
	update    expression.UpdateBuilder
	condition expression.ConditionBuilder

	// used by Manager.Update.
	optFns                        []func(*dynamodb.Options)
	values                        interface{}
	valuesOnConditionCheckFailure interface{}
}

// DisableOptimisticLocking disables optimistic locking logic.
func (o *UpdateOptions) DisableOptimisticLocking() *UpdateOptions {
	o.EnableOptimisticLocking = false
	return o
}

// DisableAutoGeneratedTimestamps disables auto-generated timestamps logic.
func (o *UpdateOptions) DisableAutoGeneratedTimestamps() *UpdateOptions {
	o.EnableAutoGeneratedTimestamps = false
	return o
}

// WithTableName overrides [UpdateOptions.TableName].
func (o *UpdateOptions) WithTableName(tableName string) *UpdateOptions {
	o.TableName = &tableName
	return o
}

// WithReturnValues sets [UpdateOptions.ReturnValues] and instructs Update to decode the returned attributes to the
// optional out argument.
//
// If out is given, it must be a struct pointer that can be passed to [attributevalue.Decoder.Decode].
func (o *UpdateOptions) WithReturnValues(returnValue types.ReturnValue, out interface{}) *UpdateOptions {
	o.ReturnValues, o.values = returnValue, out
	return o
}

// WithReturnValuesOnConditionCheckFailure sets [UpdateOptions.ReturnValuesOnConditionCheckFailure] and instructs Update
// to decode the returned attributes to the optional out argument.
//
// If out is given, it must be a struct pointer that can be passed to [attributevalue.Decoder.Decode].
func (o *UpdateOptions) WithReturnValuesOnConditionCheckFailure(returnValues types.ReturnValuesOnConditionCheckFailure, out interface{}) *UpdateOptions {
	o.ReturnValuesOnConditionCheckFailure, o.valuesOnConditionCheckFailure = returnValues, out
	return o
}

// WithOptions adds SDK options to the UpdateItem call following the ones provided by NewManager.
func (o *UpdateOptions) WithOptions(optFns ...func(*dynamodb.Options)) *UpdateOptions {
	o.optFns = append(o.optFns, optFns...)
	return o
}

// And adds an expression.And to the condition expression.
func (o *UpdateOptions) And(right expression.ConditionBuilder, other ...expression.ConditionBuilder) *UpdateOptions {
	if o.condition.IsSet() {
		o.condition = o.condition.And(right, other...)
		return o
	}

	switch len(other) {
	case 0:
		o.condition = right
	case 1:
		o.condition = right.And(other[0])
	default:
		o.condition = right.And(other[0], other[1:]...)
	}
	return o
}

// Or adds an expression.And to the condition expression.
func (o *UpdateOptions) Or(right expression.ConditionBuilder, other ...expression.ConditionBuilder) *UpdateOptions {
	if o.condition.IsSet() {
		o.condition = o.condition.Or(right, other...)
		return o
	}

	switch len(other) {
	case 0:
		o.condition = right
	case 1:
		o.condition = right.Or(other[0])
	default:
		o.condition = right.Or(other[0], other[1:]...)
	}
	return o
}

// Add adds an [expression.UpdateBuilder.Add] expression.
//
// Like all other UpdateOptions methods to modify the update expression, the name and value will be wrapped with an
// `expression.Name` and `expression.Value`.
func (o *UpdateOptions) Add(name string, value interface{}) *UpdateOptions {
	o.update = o.update.Add(expression.Name(name), expression.Value(value))

	return o
}

// Delete adds an [expression.UpdateBuilder.Delete] expression.
//
// Like all other UpdateOptions methods to modify the update expression, the name and value will be wrapped with an
// `expression.Name` and `expression.Value`.
func (o *UpdateOptions) Delete(name string, value interface{}) *UpdateOptions {
	o.update = o.update.Delete(expression.Name(name), expression.Value(value))

	return o
}

// Set adds an [expression.UpdateBuilder.Set] expression.
//
// Like all other UpdateOptions methods to modify the update expression, the name and value will be wrapped with an
// `expression.Name` and `expression.Value`.
func (o *UpdateOptions) Set(name string, value interface{}) *UpdateOptions {
	o.update = o.update.Set(expression.Name(name), expression.Value(value))

	return o
}

// SetOrRemove adds either Set or Remove action to the update expression.
//
// If set is true, a SET action will be added.
// If set is false, only when remove is true then a REMOVE action will be added.
//
// | set   | remove | action
// | true  | *      | SET
// | false | true   | REMOVE
// | false | false  | no-op
//
// This is useful for distinguishing between PUT/POST (remove=true) that replaces attributes with clobbering behaviour
// vs. PATCH (remove=false) that will only update attributes that are non-nil. An example is given:
//
//	func PUT(body Request) {
//		// because it's a PUT request, if notes is empty, instead of writing empty string to database, we'll remove it.
//		opts.SetOrRemove(true, true, "notes", body.Notes)
//	}
//
//	func PATCH(body Request) {
//		// only when notes is non-empty that we'll update it. an empty notes just means caller didn't try to update it.
//		opts.SetOrRemove(body.Notes != "", false, "notes", body.Notes)
//	}
//
//	func CreateUpdateItem(method string, body Request) {
//		// an attempt to unify the methods may look like this.
//		opts.SetOrRemove(expression.UpdateBuilder{}, body.Notes != "", method != "PATCH", "notes", body.Notes)
//	}
//
// Like all other UpdateOptions methods to modify the update expression, the name and value will be wrapped with an
// `expression.Name` and `expression.Value`.
func (o *UpdateOptions) SetOrRemove(set, remove bool, name string, value interface{}) *UpdateOptions {
	if set {
		o.update = o.update.Set(expression.Name(name), expression.Value(value))
		return o
	}

	if remove {
		o.update = o.update.Remove(expression.Name(name))
	}

	return o
}

// SetOrRemoveStringPointer is a specialization of SetOrRemove for string pointer value.
//
// If ptr is a nil pointer, no action is taken. If ptr dereferences to an empty string, a REMOVE action is used.
// A non-empty string otherwise will result in a SET action.
//
// Like all other UpdateOptions methods, the name will be wrapped with an `expression.Name` and dereferenced value
// `expression.Value`.
func (o *UpdateOptions) SetOrRemoveStringPointer(name string, ptr *string) *UpdateOptions {
	if ptr == nil {
		return o
	}

	if v := *ptr; v != "" {
		o.update = o.update.Set(expression.Name(name), expression.Value(v))
		return o
	}

	o.update = o.update.Remove(expression.Name(name))
	return o
}

// Remove adds an [expression.UpdateBuilder.Set] expression.
//
// Like all other UpdateOptions methods to modify the update expression, the name and value will be wrapped with an
// `expression.Name` and `expression.Value`.
func (o *UpdateOptions) Remove(name string) *UpdateOptions {
	o.update = o.update.Remove(expression.Name(name))

	return o
}
